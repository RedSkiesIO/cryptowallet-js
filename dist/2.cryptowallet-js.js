(window.webpackJsonpcryptowallet_js=window.webpackJsonpcryptowallet_js||[]).push([[2],{1:function(e,t,n){"use strict";n.r(t);var r,i,s=n(202),a=n(203),o=n(129),c=n(216),d=n(468),h=n(143),p=n(246),u=n.n(p),l=n(252);i=r||(r={}),(i.SDKS||(i.SDKS={})).GenericSDK=class{constructor(e){this.bitcoinlib=d,this.networks=l,this.bip39=o,this.wif=h,this.axios=u.a,e&&(this.networkInfo=e)}generateHDWallet(e,t){if(!this.bip39.validateMnemonic(e))throw new TypeError("Invalid entropy");const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n)throw new Error("Invalid network");const r=n.bip,i=c.fromMasterSeed(this.bip39.mnemonicToSeed(e));let s,a,o=0;return n.segwit?(s=i.derive(`m/49'/${r}'/0'/0`),a=i.derive(`m/49'/${r}'/0'/1`),o=49):"REGTEST"===n.name?(s=i.derive("m/0"),a=i.derive("m/1"),o=0):(s=i.derive(`m/44'/${r}'/0'/0`),a=i.derive(`m/44'/${r}'/0'/1`),o=44),{bip:o,ext:s.toJSON(),int:a.toJSON(),type:r,network:n}}generateKeyPair(e,t,n){if(!e.network.connect)throw new Error("Invalid wallet type");let r=c.fromJSON(e.ext);n&&(r=c.fromJSON(e.int));const i=r.deriveChild(t);let s=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:i.publicKey,network:e.network.connect}),network:e.network.connect});e.network.segwit||(s=this.bitcoinlib.payments.p2pkh({pubkey:i.publicKey,network:e.network.connect}));const{address:a}=s;return{address:a,publicKey:i.publicKey.toString("hex"),privateKey:this.wif.encode(e.network.connect.wif,i.privateKey,!0),derivationPath:`m/${e.bip}'/${e.type}'/0'/0/${t}`,type:e.network.name,network:e.network,change:n}}generateAddress(e,t,n){if(!e.network.connect)throw new Error("Invalid wallet type");let r=c.fromJSON(e.ext);n&&(r=c.fromJSON(e.int));const i=r.deriveChild(t);let s=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:i.publicKey,network:e.network.connect}),network:e.network.connect});e.network.segwit||(s=this.bitcoinlib.payments.p2pkh({pubkey:i.publicKey,network:e.network.connect}));const{address:a}=s;return{address:a,index:t,type:e.network.name,change:n}}importWIF(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network type");const r=this.bitcoinlib.ECPair.fromWIF(e,n.connect);let i=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:r.publicKey,network:n.connect}),network:n.connect});n.segwit||(i=this.bitcoinlib.payments.p2pkh({pubkey:r.publicKey,network:n.connect}));const{address:s}=i;return{address:s,keyPair:r}}broadcastTx(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network type");return new Promise((t,r)=>{n.segwit?this.axios.post(n.broadcastUrl,{tx_hex:e}).then(e=>{const n=e.data.data.txid;return t(n)}).catch(e=>r(new Error("Transaction failed"))):this.axios.post(`${n.discovery}/tx/send`,{rawtx:e}).then(e=>{const{txid:n}=e.data;return t(n)}).catch(e=>r(new Error("Transaction failed")))})}validateAddress(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];try{this.bitcoinlib.address.toOutputScript(e,n.connect)}catch(e){return!1}return!0}getTransactionFee(e){const t=this.networkInfo?this.networkInfo:this.networks[e];if(!t||!t.connect)throw new Error("Invalid network type");return new Promise((e,n)=>{const r=t.feeApi;this.axios.get(r).then(t=>{e({high:t.data.high_fee_per_kb/1e3,medium:t.data.medium_fee_per_kb/1e3,low:t.data.low_fee_per_kb/1e3})}).catch(e=>n(e.message))})}createRawTx(e,t,n,r,i,o,c,d){if(!r||!r.network||!r.network.connect)throw new Error("Invalid wallet type");if(!this.validateAddress(i,r.network.name))throw new Error(`Invalid to address "${i}"`);const h=c,p=Math.floor(1e8*o),u=r.network;let l;return new Promise(async(c,w)=>{if(0===n.length)return w(new Error("You don't have enough balance to cover transaction"));let m=0;for(let e=0;e<n.length;e+=1)m+=n[e].value;if(m-p>0){let w=[{address:i,value:p}],m=s(n,w,h);if(t.length>1){t.forEach(e=>{const t={address:e};w.push(t)});const{inputs:e}=m;m=a(e,w,h)}d&&(m=a(n,w=[{address:i}],h));const{inputs:E,outputs:f}=m;let{fee:y}=m;const b=[],g=[],v=[];E.forEach(t=>{e.forEach(e=>{let n;if(t.address===e.address){e.change?(n=this.generateKeyPair(r,e.index,!0),v.push(e)):n=this.generateKeyPair(r,e.index);const t=this.bitcoinlib.ECPair.fromWIF(n.privateKey,u.connect),i=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:u.connect}),s=this.bitcoinlib.payments.p2sh({redeem:i,network:u.connect});b.push(t),g.push(s)}})});const T=new this.bitcoinlib.TransactionBuilder(u.connect);T.setVersion(1),E.forEach(e=>{T.addInput(e.txid,e.vout)});let k=0;d?(f.forEach(e=>{k+=e.value}),T.addOutput(i,k)):f.forEach(e=>{let{address:n}=e;e.address||([n]=t),T.addOutput(n,e.value)});let I=0;E.forEach(e=>{r.network.segwit?T.sign(I,b[I],g[I].redeem.output,void 0,E[I].value):T.sign(I,b[I]),I+=1}),l=T.build().toHex();const S=[],_=1e3,x=E.map(e=>(S.push(e.address),e.txid)),A={fee:y/=1e8,change:t,receiver:[i],confirmed:!1,inputs:x,confirmations:0,hash:T.build().getId(),blockHeight:-1,sent:!0,value:o,sender:S,receivedTime:(new Date).getTime()/_,confirmedTime:void 0};return d&&(A.value=k/1e8),c({changeInputUsed:v,transaction:A,hexTx:l,utxo:E})}return w(new Error("You don't have enough Satoshis to cover the miner fee."))})}verifyTxSignature(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network type");const r=e.pubKeys.map(e=>this.bitcoinlib.ECPair.fromPublicKey(Buffer.from(e,"hex"),n.connect)),i=this.bitcoinlib.Transaction.fromHex(e.txHex),s=[];return i.ins.forEach((e,t)=>{const n=r[t],a=this.bitcoinlib.payments.p2pkh({pubkey:n.publicKey,input:e.script}),o=this.bitcoinlib.script.signature.decode(a.signature),c=i.hashForSignature(t,a.output,o.hashType);s.push(n.verify(c,o.signature))}),s.every(e=>!0===e)}accountDiscovery(e,t){if(!e||!e.network||!e.network.connect)throw new Error("Invalid wallet type");const n=e.network.discovery;let r=[];const i=[];let s=[],a=!1;t&&(a=!0);const o=(e,t)=>{const a=`${n}/addr/${e}?noTxList=1`;return new Promise(async(n,o)=>{try{const c=await this.axios.get(a);if(!c.data)return o(new Error("API ERROR"));const d={address:e,received:c.data.totalReceived,balance:c.data.balance,index:t};return d.received>0?(r.push(d),i.push(d.index)):s.push(d.index),n(d)}catch(e){return o(e)}})};return new Promise(async(n,c)=>{let d=0;const h=async()=>{const n=[];for(let r=d;r<d+20;r+=1){const i=r,s=this.generateKeyPair(e,i,t);n.push(o(s.address,i))}try{await Promise.all(n)}catch(e){throw e}if(s.length>0&&i.length>0){const e=Math.max(...i)+1;d=e}s.length<20&&(s=[],await h())};try{await h()}catch(e){return c(e)}const p={change:a,nextAddress:d},u=r;return t&&(p.used=u,r=r.filter(e=>0!==e.balance)),p.active=r,n(p)})}getTransactionHistory(e,t,n,r){const i=this.networkInfo?this.networkInfo:this.networks[t];if(!i||!i.connect)throw new Error("Invalid network");if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((t,s)=>{const a=`${i.discovery}/addrs/txs`;this.axios.post(a,{addrs:e.toString(),from:n,to:r}).then(i=>{if(0===i.data.totalItems)return t();let s=!1;i.data.totalItems>r&&(s=!0);const a=i.data.items,o=[];a.forEach(t=>{let n=!1;t.confirmations>5&&(n=!0);let r=!1,i=0;const s=[],a=[],c=[],d=[];t.vin.forEach(t=>{e.includes(t.addr)&&(r=!0),c.push(t.addr),d.push(t.txid)}),t.vout.forEach(t=>{const n=t.scriptPubKey.addresses,o=parseFloat(t.value);n.forEach(t=>{t[0],r&&!e.includes(t)?(a.push(t),i+=o):!r&&e.includes(t)?(i+=o,a.push(t)):s.push(t)})});const h={sent:r,value:i,change:s,confirmed:n,inputs:d,confirmations:t.confirmations,hash:t.txid,blockHeight:t.blockheight,fee:t.fees,sender:c,receiver:a,receivedTime:t.time,confirmedTime:t.blocktime};o.push(h)});const c={more:s,from:n,to:r,address:e,totalTransactions:i.data.totalItems,txs:o};return t(c)}).catch(e=>s(new Error("API failed to get transaction history")))})}getBalance(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network");if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((t,r)=>{let i=0;const s=`${n.discovery}/addrs/utxo`;this.axios.post(s,{addrs:e.toString()}).then(e=>0===e.data.length?t(i=0):(e.data.forEach(e=>{i+=e.amount}),t(i))).catch(e=>r(new Error("API failed to return a balance")))})}};var w,m=r.SDKS.GenericSDK;!function(e){!function(e){!function(e){e.BitcoinSDK=class extends m{constructor(e){super(e)}generateSegWitAddress(e){if(!e.network||!e.network.connect)throw new Error("Invalid keypair type");const t=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),{address:n}=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:e.network.connect});return n}generateSegWitP2SH(e){if(!e.network||!e.network.connect)throw new Error("Invalid keypair type");const t=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),{address:n}=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:e.network.connect}),network:e.network.connect});return n}generateSegWit3of4MultiSigAddress(e,t,n,r,i){const s=this.networkInfo?this.networkInfo:this.networks[i];if(!s||!s.connect)throw new Error("Invalid network");try{const i=[e,t,n,r].map(e=>Buffer.from(e,"hex")),{address:a}=this.bitcoinlib.payments.p2wsh({redeem:this.bitcoinlib.payments.p2ms({pubkeys:i,m:3,network:s.connect}),network:s.connect});return a}catch(e){throw new Error("Invalid public key used")}}generateP2SHMultiSig(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network");try{const t=e.map(e=>Buffer.from(e,"hex")),{address:r}=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wsh({redeem:this.bitcoinlib.payments.p2ms({pubkeys:t,m:t.length,network:n.connect}),network:n.connect}),network:n.connect});return r}catch(e){throw new Error("Invalid public key used")}}getUTXOs(e,t){const n=this.networkInfo?this.networkInfo:this.networks[t];if(!n||!n.connect)throw new Error("Invalid network");if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((t,r)=>{const i=`${n.discovery}/addrs/utxo`;this.axios.post(i,{addrs:e.toString()}).then(e=>{const n=[];return 0===e.data.length?t(n):(e.data.forEach(e=>{const t=e;t.value=e.satoshis,n.push(t)}),t(n))}).catch(e=>r(new Error("Failed to fetch UTXOs")))})}createTxToMany(e,t,n,r,i,o,c){if(!r.network||!r.network.connect)throw new Error("Invalid wallet type");const d=c,h=o.reduce((e,t)=>e+t),p=Math.floor(1e8*h),u=r.network;let l;return new Promise(async(c,w)=>{if(0===n.length)return w(new Error("You don't have enough balance to cover transaction"));let m=0;for(let e=0;e<n.length;e+=1)m+=n[e].value;if(m-p-d>0){const p=[],w=(e,t)=>{const n={address:e,value:Math.floor(1e8*o[t])};p.push(n)};i.forEach(w);let m=s(n,p,d);if(t.length>1){t.forEach(e=>{const t={address:e};p.push(t)});const{inputs:e}=m;m=a(e,p,d)}const{inputs:E,outputs:f}=m;let{fee:y}=m;const b=[],g=[],v=[];E.forEach(t=>{e.forEach(e=>{let n;if(t.address===e.address){e.change?(n=this.generateKeyPair(r,e.index,!0),v.push(e)):n=this.generateKeyPair(r,e.index);const t=this.bitcoinlib.ECPair.fromWIF(n.privateKey,u.connect),i=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:u.connect}),s=this.bitcoinlib.payments.p2sh({redeem:i,network:u.connect});b.push(t),g.push(s)}})});const T=new this.bitcoinlib.TransactionBuilder(u.connect);T.setVersion(1),E.forEach(e=>{T.addInput(e.txid,e.vout)}),f.forEach(e=>{let{address:n}=e;e.address||([n]=t),T.addOutput(n,e.value)});let k=0;E.forEach(e=>{r.network.segwit?T.sign(k,b[k],g[k].redeem.output,void 0,E[k].value):T.sign(k,b[k]),k+=1}),l=T.build().toHex();const I=[];E.forEach(e=>{I.push(e.address)});const S=1e3,_={fee:y/=1e8,change:t,receiver:[i],confirmed:!1,confirmations:0,hash:T.build().getId(),blockHeight:-1,sent:!0,value:h,sender:I,receivedTime:(new Date).getTime()/S,confirmedTime:void 0};return c({changeInputUsed:v,transaction:_,hexTx:l,utxo:E})}return w(new Error("You don't have enough Satoshis to cover the miner fee."))})}create1t1tx(e,t,n,r,i,s){if(!e.network||!e.network.connect)throw new Error("Invalid keypair");const a=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),o=this.bitcoinlib.payments.p2wpkh({pubkey:a.publicKey,network:e.network.connect}),c=this.bitcoinlib.payments.p2sh({redeem:o,network:e.network.connect}),d=new this.bitcoinlib.TransactionBuilder(e.network.connect);return d.setVersion(1),d.addInput(t,n),d.addOutput(i,s),e.network.segwit?d.sign(0,a,c.redeem.output,void 0,r):d.sign(0,a),d.build().toHex()}create2t2tx(e,t,n,r,i,s){if(!(e.network&&e.network.connect&&t.network&&t.network.connect))throw new Error("Invalid keypair");const a=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),o=this.bitcoinlib.ECPair.fromWIF(t.privateKey,t.network.connect),c=this.bitcoinlib.payments.p2wpkh({pubkey:a.publicKey,network:e.network.connect}),d=this.bitcoinlib.payments.p2wpkh({pubkey:o.publicKey,network:t.network.connect}),h=this.bitcoinlib.payments.p2sh({redeem:c,network:e.network.connect}),p=this.bitcoinlib.payments.p2sh({redeem:d,network:t.network.connect}),u=new this.bitcoinlib.TransactionBuilder(e.network.connect);return u.setVersion(1),u.addInput(n.txid,n.vout),u.addInput(r.txid,r.vout),u.addOutput(i.address,i.amount),u.addOutput(s.address,s.amount),e.network.segwit?u.sign(0,a,h.redeem.output,void 0,i.amount):u.sign(0,a),t.network.segwit?u.sign(1,o,p.redeem.output,void 0,s.amount):u.sign(1,o),u.build().toHex()}}}(e.Bitcoin||(e.Bitcoin={}))}(e.SDKS||(e.SDKS={}))}(w||(w={}));var E,f=w.SDKS.Bitcoin.BitcoinSDK,y=n(524),b=n(150),g=n(109),v=n(151);!function(e){!function(e){!function(e){e.EthereumSDK=class extends m{constructor(e){super(e),this.Bip=y,this.ethereumlib=b,this.Web3=v,e&&(this.api=e)}generateKeyPair(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");const n=this.Bip.fromExtendedKey(e.ext.xpriv).deriveChild(t);return{publicKey:n.getWallet().getPublicKeyString(),address:n.getWallet().getChecksumAddressString(),derivationPath:`m/44'/60'/0'/0/${t}`,privateKey:n.getWallet().getPrivateKeyString(),type:"Ethereum",network:this.api||e.network}}generateAddress(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");return{index:t,address:this.Bip.fromExtendedKey(e.ext.xpriv).deriveChild(t).getWallet().getChecksumAddressString(),type:e.network.name}}validateAddress(e){return this.Web3.utils.isAddress(e.toLowerCase())}getTransactionFee(e){if(!this.networks[e]||this.networks[e].connect)throw new Error("Invalid network");return new Promise((t,n)=>{const r=this.api?this.api.feeApi:this.networks[e].feeApi;this.axios.get(r).then(e=>t({high:e.data.high_gas_price,medium:e.data.medium_gas_price,low:e.data.low_gas_price,txHigh:21e3*e.data.high_gas_price/1e18,txMedium:21e3*e.data.medium_gas_price/1e18,txLow:21e3*e.data.low_gas_price/1e18})).catch(e=>n(e.message))})}importWIF(e,t){const n=Buffer.from(e,"hex"),r=this.ethereumlib.fromPrivateKey(n);return{publicKey:`0x${r.getPublicKeyString()}`,address:r.getChecksumAddressString(),privateKey:`0x${r.getPrivateKey().toString("hex")}`,type:this.networks[t].name}}createEthTx(e,t,n,r,i=25e3){const s=Buffer.from(e.privateKey.substr(2),"hex"),a=new this.Web3(e.network.provider);return new Promise(async(o,c)=>{const d=await a.eth.getTransactionCount(e.address),h=n.toString(),p=r.toString(),u=new g({nonce:d,gasPrice:a.utils.toHex(p),gasLimit:a.utils.toHex(i),to:t,value:a.utils.toHex(a.utils.toWei(h)),chainId:e.network.chainId});u.sign(s);const l=`0x${u.serialize().toString("hex")}`;return o({transaction:{hash:a.utils.sha3(l),fee:a.utils.fromWei((r*i).toString(),"ether"),receiver:t,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:n,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3},hexTx:l})})}broadcastTx(e,t){const n=this.api?this.api.provider:this.networks[t].provider,r=new this.Web3(n);return new Promise(async(t,n)=>{r.eth.sendSignedTransaction(e,(e,r)=>e?n(e):t({hash:r}))})}verifyTxSignature(e){const t=new g(e);return this.VerifyTx=e,!!t.verifySignature()}getTransactionHistory(e,t,n,r){const i=[],s=r=>new Promise(async(s,a)=>{let o;o=this.api?`${this.api.etherscan}?module=account&action=txlist&address=${r}&startblock=${n}&sort=desc`+(this.api.etherscan?`&apikey=${this.api.etherscanKey}`:null):`${this.networks[t].getTranApi+r}&startblock=${n}&sort=desc&apikey=${this.networks.ethToken}`,await this.axios.get(o).then(async t=>t.data.result?(t.data.result.forEach(t=>{let n=t.to,r=!1,s=!1,a=!1;t.from===e[0].toLowerCase()&&(r=!0),t.confirmations>11&&(s=!0),t.to||(n=t.contractAddress,a=!0);const o={sent:r,receiver:n,contractCall:a,confirmed:s,hash:t.hash,blockHeight:t.blockNumber,fee:(t.cumulativeGasUsed/1e9).toString(),value:t.value/1e18,sender:t.from,receivedTime:t.timeStamp,confirmedTime:t.timeStamp,confirmations:t.confirmations};i.push(o)}),s()):s()).catch(e=>a(e))});return new Promise(async(t,n)=>{const r=[];e.forEach(async e=>{r.push(new Promise(async(t,n)=>t(s(e))))});try{await Promise.all(r)}catch(e){return n(e)}return t({addresses:e,totalTransactions:i.length,txs:i})})}getBalance(e,t){let n=0;const r=[],i=e=>new Promise(async(r,i)=>{let s;s=this.api?`${this.api.etherscan}?module=account&action=balance&address=${e}&tag=latest`+(this.api.etherscan?`&apikey=${this.api.etherscanKey}`:null):`${this.networks[t].getBalanceApi+e}&tag=latest&apikey=${this.networks.ethToken}`,await this.axios.get(s).then(e=>{n+=e.data.result,r()}).catch(e=>i(e))});return new Promise(async(t,s)=>{e.forEach(e=>{r.push(new Promise(async(t,n)=>t(i(e))))});try{await Promise.all(r)}catch(e){return s(e)}return t(n<1e12?0:n/1e18)})}accountDiscovery(e,t){const n=[];for(let t=0;t<10;t+=1){const r={address:this.generateKeyPair(e,t).address,index:t,type:e.network.name};n.push(r)}return n}}}(e.Ethereum||(e.Ethereum={}))}(e.SDKS||(e.SDKS={}))}(E||(E={}));var T,k=E.SDKS.Ethereum.EthereumSDK,I=n(309),S=n(720),_=n.n(S),x=n(809),A=n(185),K=n.n(A),P=n(181),R=n.n(P),N=n(123);!function(e){!function(e){!function(e){e.CatalystSDK=class extends m{constructor(e){super(e),this.ethereumlib=b,this.Web3=v,this.bip39=o,this.walletHdpath="m/44'/42069'/",this.api=e}generateHDWallet(e,t){if(!this.bip39.validateMnemonic(e))throw new TypeError("Invalid entropy");return{ext:this.bip39.mnemonicToSeedHex(e),int:null,bip:44,type:42069,network:this.api}}generateKeyPair(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");const n=Object(I.derivePath)(`${this.walletHdpath+t}'`,e.ext),r=K.a.generateFromSeed(n.key);return{publicKey:r.getPublicKeyString(),address:r.getAddressString(),derivationPath:`${this.walletHdpath+t}'`,privateKey:r.getPrivateKeyString(),type:"Catalyst",network:e.network}}generateAddress(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");const n=Object(I.derivePath)(`${this.walletHdpath+t}'`,e.ext);return{index:t,address:K.a.generateFromSeed(n.key).getAddressString(),type:e.network.name}}validateAddress(e,t){return this.Web3.utils.isAddress(e.toLowerCase())}getTransactionFee(e){if(!this.networks[e]||this.networks[e].connect)throw new Error("Invalid network");return new Promise((t,n)=>{const r=this.networks[e].feeApi;this.axios.get(r).then(e=>t({high:e.data.high_gas_price,medium:e.data.medium_gas_price,low:e.data.low_gas_price,txHigh:21e3*e.data.high_gas_price/1e18,txMedium:21e3*e.data.medium_gas_price/1e18,txLow:21e3*e.data.low_gas_price/1e18})).catch(e=>n(e.message))})}importWIF(e,t){const n=Buffer.from(e,"hex"),r=this.ethereumlib.fromPrivateKey(n);return{publicKey:`0x${r.getPublicKeyString()}`,address:r.getChecksumAddressString(),privateKey:`0x${r.getPrivateKey().toString("hex")}`,type:this.networks[t].name}}createEthTx(e,t,n,r){const i=new this.Web3(this.api.provider);return new Promise(async(s,a)=>{const o=await i.eth.getTransactionCount(e.address),c=n.toString(),d=r.toString(),h=new R.a({nonce:`0x${parseInt(o,16)}`,gasPrice:i.utils.toHex(d),gasLimit:i.utils.toHex(25e3),to:t,value:i.utils.toHex(i.utils.toWei(c)),data:"0x0"});await h.sign(e.privateKey);const p=function(e){return Array.prototype.map.call(e,e=>`0${(255&e).toString(16)}`.slice(-2)).join("")}(h.serialize());return s({transaction:{hash:i.utils.sha3(h.serialize()),fee:i.utils.fromWei((25e3*r).toString(),"ether"),receiver:t,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:n,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3},hexTx:p})})}broadcastTx(e,t){const n=new this.Web3(this.api.provider);return new Promise(async(t,r)=>{n.eth.sendSignedTransaction(e,(e,n)=>e?r(e):t({hash:n}))})}broadcastProviderTx(e,t,n){const r=new x.HDWalletProvider([t.privateKey],this.api.provider),i=new this.Web3(r),s=new R.a(e).deserialize(),a=s.getAmount(),o=s.getGasPrice(),c=s.getGasLimit(),d=s.getReceiverAddress(),h=s.getData();return new Promise(async(e,n)=>{i.eth.sendTransaction({from:t.address,to:Object(N.hexStringFromBytes)(d),value:Object(N.numberFromBytes)(a),gasPrice:Object(N.numberFromBytes)(o),gasLimit:c,data:Object(N.hexStringFromBytes)(h)},(t,r)=>t?n(t):e({hash:r}))})}verifyTxSignature(e){const t=new g(e);return this.VerifyTx=e,!!t.verifySignature()}getTransactionHistory(e,t,n,r){const i=new URL(this.api.provider),s=new _.a({transport:{host:i.hostname,port:parseInt(i.port),type:"https",path:"/api/eth/request"}});s.startBatch();const a=setInterval(()=>{s.stopBatch(),s.startBatch()},100),o=async t=>{const i=[],a={};let o=n,c=r;if(!r){const e=await s.eth_blockNumber();o=e>=100?e-100:0,c=e}return(await(async(e,t,n)=>{const r=[];for(let i=e;i<=t;i+=1)r.push(n.eth_getBlockByNumber(`0x${i.toString(16)}`,!0));return Promise.all(r)})(o,c,s)).filter(e=>e).forEach(({transactions:e,timestamp:t})=>{console.log(e),e.length>0&&(i.push(...e),e.forEach(e=>{a[e]=t}))}),(await(async(e,t)=>{const n=[];e.forEach(e=>{n.push(t.eth_getTransactionByHash(e))});const r=Promise.all(n);return console.log(r),r})(i,s)).reduce((n,r)=>(r.from!==e[0]&&r.to!==t||(r.timestamp=a[r.hash],n.push(r)),n),[])},c=[];return new Promise(async(t,n)=>{const r=[];e.forEach(async e=>{r.push(new Promise(async(t,n)=>t((async e=>{(await o(e)).forEach(t=>{let n=t.to,r=!1,i=!1,s=!1;t.from===e.toLowerCase()&&(r=!0),t.confirmations>=1&&(i=!0),t.to||(n=t.contractAddress,s=!0);const a={sent:r,receiver:n,contractCall:s,confirmed:i,hash:t.hash,blockHeight:parseInt(t.blockNumber,16),fee:(parseInt(t.gas,16)*parseInt(t.gasPrice,16)/1e18).toString(),value:parseInt(t.value,16)/1e18,sender:t.from,receivedTime:parseInt(t.timestamp,16),confirmedTime:parseInt(t.timestamp,16),confirmations:1};c.push(a)})})(e))))});try{await Promise.all(r)}catch(e){return n(e)}const i={addresses:e,totalTransactions:c.length,txs:c};return clearInterval(a),t(i)})}getBalance(e,t){const n=new URL(this.api.provider),r=new _.a({transport:{host:n.hostname,port:parseInt(n.port),type:"https",path:"/api/eth/request"}});return(e=>new Promise(async(t,n)=>{const i=await r.eth_getBalance(e);t(i?parseInt(i,16)/1e18:0)}))(e[0])}accountDiscovery(e,t){const n=[];for(let t=0;t<10;t+=1){const r={address:this.generateKeyPair(e,t).address,index:t,type:e.network.name};n.push(r)}return n}}}(e.Catalyst||(e.Catalyst={}))}(e.SDKS||(e.SDKS={}))}(T||(T={}));var C=T.SDKS.Catalyst.CatalystSDK;var O,H=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}];!function(e){!function(e){!function(e){e.ERC20SDK=class{constructor(e){this.json=H,this.networks=l,this.axios=p,this.Tx=g,this.Web3=v,e&&(this.api=e)}generateERC20Wallet(e,t,n,r,i){if(!this.Web3.utils.isAddress(r.toLowerCase()))throw new Error("This is not a valid ERC20 contract address");return{decimals:i,address:e.address,network:e.network,name:t,type:e.type,symbol:n,contract:r}}broadcastTx(e,t){const n=this.api?this.api.provider:this.networks[t].provider,r=new this.Web3(n);return new Promise(async(t,n)=>{r.eth.sendSignedTransaction(e,(e,r)=>e?n(e):t({hash:r}))})}estimateGas(e,t,n,r){const i=this.api?this.api.provider:this.networks[r].provider,s=new(new this.Web3(i).eth.Contract)(this.json,e.contract),a=(n*10**e.decimals).toString();return new Promise(async(n,r)=>{s.methods.transfer(t,a).estimateGas({from:e.address},(e,t)=>e?r(e):n(t))})}transfer(e,t,n,r,i){const s=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract),a=(r*10**e.decimals).toString(),o=s.methods.transfer(n,a).encodeABI();return this.createTx(e,t,o,i,n,r)}approveAccount(e,t,n,r,i){const s=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract),a=(r*10**e.decimals).toString(),o=s.methods.approve(n,a).encodeABI();return this.createTx(e,t,o,i)}transferAllowance(e,t,n,r,i){return new Promise(async(s,a)=>{const o=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract);if(await this.checkAllowance(e,n)>=r){const a=(r*10**e.decimals).toString(),c=o.methods.transferFrom(n,e.address,a).encodeABI();return s(this.createTx(e,t,c,i))}return s("You don't have enough allowance")})}checkAllowance(e,t){return this.wallet=e,new Promise(async(n,r)=>{const i=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract);return n(await i.methods.allowance(t,e.address).call())})}getBalance(e){return this.wallet=e,new Promise(async(t,n)=>{const r=this.api?this.api.provider:e.network.provider,i=new(new this.Web3(r).eth.Contract)(this.json,e.contract);return t(await i.methods.balanceOf(e.address).call()/10**e.decimals)})}getTokenData(e,t){return new Promise(async(n,r)=>{const i=this.api?this.api.provider:this.networks[t].provider,s=new this.Web3(i),a=this.json;if("0x"===await s.eth.getCode(e))return r(new Error("This is not a valid ERC20 contract address"));const o=new s.eth.Contract(a,e);await o.methods.balanceOf("0xcc345035D14458B3C012977f96fA1E116760D60a").call().catch(e=>r(new Error("Not a valid ERC20 contract address")));try{const e=await o.methods.decimals().call();return n({name:await o.methods.name().call(),symbol:await o.methods.symbol().call(),decimals:e})}catch(e){return n()}})}getTransactionHistory(e,t){return new Promise(async(n,r)=>{const i=this.api?`${this.api.etherscan}?module=account&action=tokentx&contractaddress=`:this.networks[e.network.name].getErc20TranApi,s=this.api?this.api.etherscanKey:this.networks.ethToken;let a=`${i+e.contract}&address=${e.address}&startblock=${t}&sort=desc`+(s?`&apikey=${s}`:null);void 0===t&&(a=`${i+e.contract}&address=${e.address}&sort=desc`+(s?`&apikey=${s}`:null)),await this.axios.get(a).then(async t=>{if(!t.data.result)return n();const r=[];return t.data.result.forEach(t=>{const n=t.to;let i=!1,s=!1;t.from===e.address.toLowerCase()&&(i=!0),t.confirmations>11&&(s=!0);const a={sent:i,receiver:n,confirmed:s,hash:t.hash,blockHeight:t.blockNumber,fee:t.cumulativeGasUsed/1e9,value:t.value/10**e.decimals,sender:t.from,confirmedTime:t.timeStamp,confirmations:t.confirmations};r.push(a)}),n(r)}).catch(e=>r(e))})}createTx(e,t,n,r,i,s){const a=new this.Web3(e.network.provider);return new Promise(async(o,c)=>{const d=await a.eth.getTransactionCount(e.address),h=r.toString();let p=1e5;if(i&&s)try{p=await this.estimateGas(e,i,s,t.network.name)}catch(e){c(e)}const u=new this.Tx({nonce:d,gasPrice:a.utils.toHex(h),gasLimit:a.utils.toHex(1e5),to:e.contract,value:0,data:n,chainId:e.network.chainId}),l=Buffer.from(t.privateKey.substr(2),"hex");u.sign(l);const w=`0x${u.serialize().toString("hex")}`;return o({hexTx:w,transaction:{fee:(r*p).toString(),hash:a.utils.sha3(w),receiver:i,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:s,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3}})})}}}(e.ERC20||(e.ERC20={}))}(e.SDKS||(e.SDKS={}))}(O||(O={}));var D,B=O.SDKS.ERC20.ERC20SDK;(D||(D={})).createSDK=function(e,t){switch(e){case"Bitcoin":return new f(t);case"Ethereum":return new k(t);case"Catalyst":return new C(t);case"ERC20":return new B(t);default:return new f(t)}};var M,U=D;!function(e){(M||(M={})).CryptoWalletJS=class{constructor(){this.SDKFactory=U}}}();t.default=M.CryptoWalletJS},252:function(e,t,n){"use strict";n.r(t),function(e){n.d(t,"ethToken",function(){return r}),n.d(t,"cryptocompare",function(){return i}),n.d(t,"BITCOIN",function(){return s}),n.d(t,"BITCOIN_TESTNET",function(){return a}),n.d(t,"LITECOIN",function(){return o}),n.d(t,"LITECOIN_TESTNET",function(){return c}),n.d(t,"DASH",function(){return d}),n.d(t,"DASH_TESTNET",function(){return h}),n.d(t,"DOGECOIN",function(){return p}),n.d(t,"DOGECOIN_TESTNET",function(){return u}),n.d(t,"VIACOIN",function(){return l}),n.d(t,"VIACOIN_TESTNET",function(){return w}),n.d(t,"ETHEREUM",function(){return m}),n.d(t,"ETHEREUM_ROPSTEN",function(){return E}),n.d(t,"ETHEREUM_RINKEBY",function(){return f}),n.d(t,"ETHEREUM_KOVAN",function(){return y}),n.d(t,"ETHEREUM_GOERLI",function(){return b}),n.d(t,"CATALYST_TESTNET",function(){return g}),n.d(t,"REGTEST",function(){return v});const r=e.env.ETHERSCAN_API_KEY,i=e.env.CRYPTOCOMPARE_API_KEY,s={name:"BITCOIN",bip:0,segwit:!0,discovery:e.env.BITCOIN_DISCOVERY,broadcastUrl:e.env.BITCOIN_BROADCAST,feeApi:e.env.BITCOIN_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"bc",bip32:{private:76066276,public:76067358},pubKeyHash:0,scriptHash:5,wif:128}},a={name:"BITCOIN_TESTNET",type:"testnet",bip:1,segwit:!0,discovery:e.env.BITCOIN_TESTNET_DISCOVERY,broadcastUrl:e.env.BITCOIN_TESTNET_BROADCAST,feeApi:e.env.BITCOIN_TESTNET_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"tb",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239}},o={name:"LITECOIN",bip:2,segwit:!0,discovery:e.env.LITECOIN_DISCOVERY,broadcastUrl:e.env.LITECOIN_BROADCAST,feeApi:e.env.LITECOIN_FEE,connect:{messagePrefix:"Litecoin Signed Message:\n",bip32:{public:27108450,private:27106558},pubKeyHash:48,scriptHash:50,wif:176}},c={name:"LITECOIN_TESTNET",type:"litecoin testnet",bip:1,segwit:!0,discovery:e.env.LITECOIN_TESTNET_DISCOVERY,broadcastUrl:e.env.LITECOIN_TESTNET_BROADCAST,feeApi:e.env.LITECOIN_TESTNET_FEE,connect:{messagePrefix:"Litecoin Signed Message:\n",bip32:{private:70709117,public:70711009},pubKeyHash:111,scriptHash:58,wif:239}},d={name:"DASH",bip:5,segwit:!1,discovery:e.env.DASH_DISCOVERY,feeApi:e.env.DASH_FEE,connect:{messagePrefix:"unused",bip32:{public:76067358,private:76066276},pubKeyHash:76,scriptHash:16,wif:204}},h={name:"DASH_TESTNET",bip:1,segwit:!1,discovery:e.env.DASH_TESTNET_DISCOVERY,feeApi:e.env.DASH_TESTNET_FEE,connect:{messagePrefix:"unused",bip32:{public:70617039,private:70615956},pubKeyHash:140,scriptHash:19,wif:239}},p={name:"DOGECOIN",bip:3,segwit:!1,connect:{messagePrefix:"Dogecoin Signed Message:\n",bip32:{public:49990397,private:49988504},pubKeyHash:30,scriptHash:22,wif:158}},u={name:"DOGECOIN_TESTNET",bip:1,segwit:!1,connect:{messagePrefix:"Dogecoin Signed Message:\n",bip32:{private:70427203,public:70429096},wif:241,public:113,scripthash:196}},l={name:"VIACOIN",segwit:!1,connect:{messagePrefix:"Viacoin Signed Message:\n",bip32:{public:76067358,private:76066276},pubKeyHash:71,scriptHash:33,wif:199}},w={name:"VIACOIN_TESTNET",segwit:!1,connect:{messagePrefix:"Viacoin Signed Message:\n",bip32:{public:70617039,private:70615956},pubKeyHash:127,scriptHash:196,wif:255}},m={name:"ETHEREUM",bip:60,feeApi:e.env.ETHEREUM_FEE,provider:e.env.ETHEREUM_PROVIDER,chainId:1},E={name:"ETHEREUM_ROPSTEN",networkName:"ropsten",bip:60,getTranApi:e.env.ETHEREUM_ROPSTEN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_ROPSTEN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_ROPSTEN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_ROPSTEN_FEE,provider:e.env.ETHEREUM_ROPSTEN_PROVIDER,chainId:3},f={name:"ETHEREUM_RINKEBY",networkName:"rinkeby",bip:60,getTranApi:e.env.ETHEREUM_RINKEBY_GET_TRAN,getBalanceApi:e.env.ETHEREUM_RINKEBY_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_RINKEBY_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_RINKEBY_FEE,provider:e.env.ETHEREUM_RINKEBY_PROVIDER,chainId:4},y={name:"ETHEREUM_KOVAN",networkName:"kovan",bip:60,getTranApi:e.env.ETHEREUM_KOVAN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_KOVAN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_KOVAN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_KOVAN_FEE,provider:e.env.ETHEREUM_KOVAN_PROVIDER,chainId:42},b={name:"ETHEREUM_GOERLI",networkName:"goerli",bip:60,getTranApi:e.env.ETHEREUM_KOVAN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_KOVAN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_KOVAN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_KOVAN_FEE,provider:e.env.ETHEREUM_KOVAN_PROVIDER,chainId:5},g={name:"CATALYST_TESTNET",networkName:"catalyst",bip:42069,getTranApi:e.env.ETHEREUM_ROPSTEN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_ROPSTEN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_ROPSTEN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_ROPSTEN_FEE,provider:"http://77.68.110.194:5005/api/eth/request",chainId:2},v={name:"REGTEST",type:"test",bip:0,discovery:e.env.BITCOIN_REGTEST_DISCOVERY,segwit:!1,feeApi:e.env.BITCOIN_REGTEST_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"bcrt",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239}}}.call(this,n(7))},370:function(e,t){},372:function(e,t){},415:function(e,t){},416:function(e,t){},718:function(e,t){},760:function(e,t){},816:function(e,t){},820:function(e,t){},833:function(e,t){function n(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}n.keys=function(){return[]},n.resolve=n,e.exports=n,n.id=833},958:function(e,t){function n(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}n.keys=function(){return[]},n.resolve=n,e.exports=n,n.id=958}}]);