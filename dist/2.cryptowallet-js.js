(window.webpackJsonpcryptowallet_js=window.webpackJsonpcryptowallet_js||[]).push([[2],{1:function(e,t,n){"use strict";n.r(t);var r,i,s=n(163),o=n(164),a=n(165),c=n(178),d=n(398),h=n(119),u=n(208),p=n.n(u),l=n(214);i=r||(r={}),(i.SDKS||(i.SDKS={})).GenericSDK=class{constructor(){this.bitcoinlib=d,this.networks=l,this.bip39=a,this.wif=h,this.axios=p.a}generateHDWallet(e,t){if(!this.bip39.validateMnemonic(e))throw new TypeError("Invalid entropy");if(!this.networks[t])throw new TypeError("Invalid network");const n=this.networks[t].bip,r=c.fromMasterSeed(this.bip39.mnemonicToSeed(e));let i,s,o=0;return this.networks[t].segwit?(i=r.derive(`m/49'/${n}'/0'/0`),s=r.derive(`m/49'/${n}'/0'/1`),o=49):"REGTEST"===this.networks[t].name?(i=r.derive("m/0"),s=r.derive("m/1"),o=0):(i=r.derive(`m/44'/${n}'/0'/0`),s=r.derive(`m/44'/${n}'/0'/1`),o=44),{bip:o,ext:i.toJSON(),int:s.toJSON(),type:n,network:this.networks[t]}}generateKeyPair(e,t,n){if(!e.network.connect)throw new Error("Invalid wallet type");let r=c.fromJSON(e.ext);n&&(r=c.fromJSON(e.int));const i=r.deriveChild(t);let s=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:i.publicKey,network:e.network.connect}),network:e.network.connect});e.network.segwit||(s=this.bitcoinlib.payments.p2pkh({pubkey:i.publicKey,network:e.network.connect}));const{address:o}=s;return{address:o,publicKey:i.publicKey.toString("hex"),privateKey:this.wif.encode(e.network.connect.wif,i.privateKey,!0),derivationPath:`m/${e.bip}'/${e.type}'/0'/0/${t}`,type:e.network.name,network:e.network,change:n}}generateAddress(e,t,n){if(!e.network.connect)throw new Error("Invalid wallet type");let r=c.fromJSON(e.ext);n&&(r=c.fromJSON(e.int));const i=r.deriveChild(t);let s=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:i.publicKey,network:e.network.connect}),network:e.network.connect});e.network.segwit||(s=this.bitcoinlib.payments.p2pkh({pubkey:i.publicKey,network:e.network.connect}));const{address:o}=s;return{address:o,index:t,type:e.network.name,change:n}}importWIF(e,t){if(!this.networks[t].connect)throw new Error("Invalid network type");const n=this.bitcoinlib.ECPair.fromWIF(e,this.networks[t].connect);let r=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:n.publicKey,network:this.networks[t].connect}),network:this.networks[t].connect});this.networks[t].segwit||(r=this.bitcoinlib.payments.p2pkh({pubkey:n.publicKey,network:this.networks[t].connect}));const{address:i}=r;return{address:i,keyPair:n}}broadcastTx(e,t){if(!this.networks[t]||!this.networks[t].connect)throw new Error("Invalid network type");return new Promise((n,r)=>{this.networks[t].segwit?this.axios.post(this.networks[t].broadcastUrl,{tx_hex:e}).then(e=>{const t=e.data.data.txid;return n(t)}).catch(e=>r(new Error("Transaction failed"))):this.axios.post(`${this.networks[t].discovery}/tx/send`,{rawtx:e}).then(e=>{const{txid:t}=e.data;return n(t)}).catch(e=>r(new Error("Transaction failed")))})}validateAddress(e,t){try{this.bitcoinlib.address.toOutputScript(e,this.networks[t].connect)}catch(e){return!1}return!0}getTransactionFee(e){if(!this.networks[e])throw new Error("Invalid network");return new Promise((t,n)=>{const r=this.networks[e].feeApi;this.axios.get(r).then(e=>{t({high:e.data.high_fee_per_kb/1e3,medium:e.data.medium_fee_per_kb/1e3,low:e.data.low_fee_per_kb/1e3})}).catch(e=>n(e.message))})}createRawTx(e,t,n,r,i,a,c,d){if(!r||!r.network||!r.network.connect)throw new Error("Invalid wallet type");if(!this.validateAddress(i,r.network.name))throw new Error(`Invalid to address "${i}"`);const h=c,u=Math.floor(1e8*a),p=r.network;let l;return new Promise(async(c,w)=>{if(0===n.length)return w(new Error("You don't have enough balance to cover transaction"));let m=0;for(let e=0;e<n.length;e+=1)m+=n[e].value;if(m-u>0){let w=[{address:i,value:u}],m=s(n,w,h);if(t.length>1){t.forEach(e=>{const t={address:e};w.push(t)});const{inputs:e}=m;m=o(e,w,h)}d&&(m=o(n,w=[{address:i}],h));const{inputs:E,outputs:y}=m;let{fee:f}=m;const b=[],g=[],v=[];E.forEach(t=>{e.forEach(e=>{let n;if(t.address===e.address){e.change?(n=this.generateKeyPair(r,e.index,!0),v.push(e)):n=this.generateKeyPair(r,e.index);const t=this.bitcoinlib.ECPair.fromWIF(n.privateKey,p.connect),i=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:p.connect}),s=this.bitcoinlib.payments.p2sh({redeem:i,network:p.connect});b.push(t),g.push(s)}})});const k=new this.bitcoinlib.TransactionBuilder(p.connect);k.setVersion(1),E.forEach(e=>{k.addInput(e.txid,e.vout)});let T=0;d?(y.forEach(e=>{T+=e.value}),k.addOutput(i,T)):y.forEach(e=>{let{address:n}=e;e.address||([n]=t),k.addOutput(n,e.value)});let S=0;E.forEach(e=>{r.network.segwit?k.sign(S,b[S],g[S].redeem.output,void 0,E[S].value):k.sign(S,b[S]),S+=1}),l=k.build().toHex();const x=[],_=1e3,I=E.map(e=>(x.push(e.address),e.txid)),A={fee:f/=1e8,change:t,receiver:[i],confirmed:!1,inputs:I,confirmations:0,hash:k.build().getId(),blockHeight:-1,sent:!0,value:a,sender:x,receivedTime:(new Date).getTime()/_,confirmedTime:void 0};return d&&(A.value=T/1e8),c({changeInputUsed:v,transaction:A,hexTx:l,utxo:E})}return w(new Error("You don't have enough Satoshis to cover the miner fee."))})}verifyTxSignature(e,t){if(!this.networks[t]||!this.networks[t].connect)throw new Error("Invalid network type");const n=e.pubKeys.map(e=>this.bitcoinlib.ECPair.fromPublicKey(Buffer.from(e,"hex"),this.networks[t].connect)),r=this.bitcoinlib.Transaction.fromHex(e.txHex),i=[];return r.ins.forEach((e,t)=>{const s=n[t],o=this.bitcoinlib.payments.p2pkh({pubkey:s.publicKey,input:e.script}),a=this.bitcoinlib.script.signature.decode(o.signature),c=r.hashForSignature(t,o.output,a.hashType);i.push(s.verify(c,a.signature))}),i.every(e=>!0===e)}accountDiscovery(e,t){if(!e||!e.network||!e.network.connect)throw new Error("Invalid wallet type");const n=this.networks[e.network.name].discovery;let r=[];const i=[];let s=[],o=!1;t&&(o=!0);const a=(e,t)=>{const o=`${n}/addr/${e}?noTxList=1`;return new Promise(async(n,a)=>{try{const c=await this.axios.get(o);if(!c.data)return a(new Error("API ERROR"));const d={address:e,received:c.data.totalReceived,balance:c.data.balance,index:t};return d.received>0?(r.push(d),i.push(d.index)):s.push(d.index),n(d)}catch(e){return a(e)}})};return new Promise(async(n,c)=>{let d=0;const h=async()=>{const n=[];for(let r=d;r<d+20;r+=1){const i=r,s=this.generateKeyPair(e,i,t);n.push(a(s.address,i))}try{await Promise.all(n)}catch(e){throw e}if(s.length>0&&i.length>0){const e=Math.max(...i)+1;d=e}s.length<20&&(s=[],await h())};try{await h()}catch(e){return c(e)}const u={change:o,nextAddress:d},p=r;return t&&(u.used=p,r=r.filter(e=>0!==e.balance)),u.active=r,n(u)})}getTransactionHistory(e,t,n,r){if(!this.networks[t].connect)throw new Error(`${t} is an invalid network`);if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((i,s)=>{const o=`${this.networks[t].discovery}/addrs/txs`;this.axios.post(o,{addrs:e.toString(),from:n,to:r}).then(t=>{if(0===t.data.totalItems)return i();let s=!1;t.data.totalItems>r&&(s=!0);const o=t.data.items,a=[];o.forEach(t=>{let n=!1;t.confirmations>5&&(n=!0);let r=!1,i=0;const s=[],o=[],c=[],d=[];t.vin.forEach(t=>{e.includes(t.addr)&&(r=!0),c.push(t.addr),d.push(t.txid)}),t.vout.forEach(t=>{const n=t.scriptPubKey.addresses,a=parseFloat(t.value);n.forEach(t=>{t[0],r&&!e.includes(t)?(o.push(t),i+=a):!r&&e.includes(t)?(i+=a,o.push(t)):s.push(t)})});const h={sent:r,value:i,change:s,confirmed:n,inputs:d,confirmations:t.confirmations,hash:t.txid,blockHeight:t.blockheight,fee:t.fees,sender:c,receiver:o,receivedTime:t.time,confirmedTime:t.blocktime};a.push(h)});const c={more:s,from:n,to:r,address:e,totalTransactions:t.data.totalItems,txs:a};return i(c)}).catch(e=>s(new Error("API failed to get transaction history")))})}getBalance(e,t){if(!this.networks[t]||!this.networks[t].connect)throw new Error(`${t} is an invalid network`);if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((n,r)=>{let i=0;const s=`${this.networks[t].discovery}/addrs/utxo`;this.axios.post(s,{addrs:e.toString()}).then(e=>0===e.data.length?n(i=0):(e.data.forEach(e=>{i+=e.amount}),n(i))).catch(e=>r(new Error("API failed to return a balance")))})}};var w,m=r.SDKS.GenericSDK;!function(e){!function(e){!function(e){e.BitcoinSDK=class extends m{generateSegWitAddress(e){if(!e.network||!e.network.connect)throw new Error("Invalid keypair type");const t=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),{address:n}=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:e.network.connect});return n}generateSegWitP2SH(e){if(!e.network||!e.network.connect)throw new Error("Invalid keypair type");const t=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),{address:n}=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:e.network.connect}),network:e.network.connect});return n}generateSegWit3of4MultiSigAddress(e,t,n,r,i){if(!this.networks[i]||!this.networks[i].connect)throw new Error("Invalid network");try{const s=[e,t,n,r].map(e=>Buffer.from(e,"hex")),{address:o}=this.bitcoinlib.payments.p2wsh({redeem:this.bitcoinlib.payments.p2ms({pubkeys:s,m:3,network:this.networks[i].connect}),network:this.networks[i].connect});return o}catch(e){throw new Error("Invalid public key used")}}generateP2SHMultiSig(e,t){if(!this.networks[t]||!this.networks[t].connect)throw new Error("Invalid network");try{const n=e.map(e=>Buffer.from(e,"hex")),{address:r}=this.bitcoinlib.payments.p2sh({redeem:this.bitcoinlib.payments.p2wsh({redeem:this.bitcoinlib.payments.p2ms({pubkeys:n,m:n.length,network:this.networks[t].connect}),network:this.networks[t].connect}),network:this.networks[t].connect});return r}catch(e){throw new Error("Invalid public key used")}}getUTXOs(e,t){if(!this.networks[t]||!this.networks[t].connect)throw new Error("Invalid network");if(!e.every(e=>this.validateAddress(e,t)))throw new Error("Invalid address used");return new Promise((n,r)=>{const i=`${this.networks[t].discovery}/addrs/utxo`;this.axios.post(i,{addrs:e.toString()}).then(e=>{const t=[];return 0===e.data.length?n(t):(e.data.forEach(e=>{const n=e;n.value=e.satoshis,t.push(n)}),n(t))}).catch(e=>r(new Error("Failed to fetch UTXOs")))})}createTxToMany(e,t,n,r,i,a,c){if(!r.network||!r.network.connect)throw new Error("Invalid wallet type");const d=c,h=a.reduce((e,t)=>e+t),u=Math.floor(1e8*h),p=this.networks[r.network.name];let l;return new Promise(async(c,w)=>{if(0===n.length)return w(new Error("You don't have enough balance to cover transaction"));let m=0;for(let e=0;e<n.length;e+=1)m+=n[e].value;if(m-u-d>0){const u=[],w=(e,t)=>{const n={address:e,value:Math.floor(1e8*a[t])};u.push(n)};i.forEach(w);let m=s(n,u,d);if(t.length>1){t.forEach(e=>{const t={address:e};u.push(t)});const{inputs:e}=m;m=o(e,u,d)}const{inputs:E,outputs:y}=m;let{fee:f}=m;const b=[],g=[],v=[];E.forEach(t=>{e.forEach(e=>{let n;if(t.address===e.address){e.change?(n=this.generateKeyPair(r,e.index,!0),v.push(e)):n=this.generateKeyPair(r,e.index);const t=this.bitcoinlib.ECPair.fromWIF(n.privateKey,p.connect),i=this.bitcoinlib.payments.p2wpkh({pubkey:t.publicKey,network:p.connect}),s=this.bitcoinlib.payments.p2sh({redeem:i,network:p.connect});b.push(t),g.push(s)}})});const k=new this.bitcoinlib.TransactionBuilder(p.connect);k.setVersion(1),E.forEach(e=>{k.addInput(e.txid,e.vout)}),y.forEach(e=>{let{address:n}=e;e.address||([n]=t),k.addOutput(n,e.value)});let T=0;E.forEach(e=>{r.network.segwit?k.sign(T,b[T],g[T].redeem.output,void 0,E[T].value):k.sign(T,b[T]),T+=1}),l=k.build().toHex();const S=[];E.forEach(e=>{S.push(e.address)});const x=1e3,_={fee:f/=1e8,change:t,receiver:[i],confirmed:!1,confirmations:0,hash:k.build().getId(),blockHeight:-1,sent:!0,value:h,sender:S,receivedTime:(new Date).getTime()/x,confirmedTime:void 0};return c({changeInputUsed:v,transaction:_,hexTx:l,utxo:E})}return w(new Error("You don't have enough Satoshis to cover the miner fee."))})}create1t1tx(e,t,n,r,i,s){if(!e.network||!e.network.connect)throw new Error("Invalid keypair");const o=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),a=this.bitcoinlib.payments.p2wpkh({pubkey:o.publicKey,network:e.network.connect}),c=this.bitcoinlib.payments.p2sh({redeem:a,network:e.network.connect}),d=new this.bitcoinlib.TransactionBuilder(e.network.connect);return d.setVersion(1),d.addInput(t,n),d.addOutput(i,s),e.network.segwit?d.sign(0,o,c.redeem.output,void 0,r):d.sign(0,o),d.build().toHex()}create2t2tx(e,t,n,r,i,s){if(!(e.network&&e.network.connect&&t.network&&t.network.connect))throw new Error("Invalid keypair");const o=this.bitcoinlib.ECPair.fromWIF(e.privateKey,e.network.connect),a=this.bitcoinlib.ECPair.fromWIF(t.privateKey,t.network.connect),c=this.bitcoinlib.payments.p2wpkh({pubkey:o.publicKey,network:e.network.connect}),d=this.bitcoinlib.payments.p2wpkh({pubkey:a.publicKey,network:t.network.connect}),h=this.bitcoinlib.payments.p2sh({redeem:c,network:e.network.connect}),u=this.bitcoinlib.payments.p2sh({redeem:d,network:t.network.connect}),p=new this.bitcoinlib.TransactionBuilder(e.network.connect);return p.setVersion(1),p.addInput(n.txid,n.vout),p.addInput(r.txid,r.vout),p.addOutput(i.address,i.amount),p.addOutput(s.address,s.amount),e.network.segwit?p.sign(0,o,h.redeem.output,void 0,i.amount):p.sign(0,o),t.network.segwit?p.sign(1,a,u.redeem.output,void 0,s.amount):p.sign(1,a),p.build().toHex()}}}(e.Bitcoin||(e.Bitcoin={}))}(e.SDKS||(e.SDKS={}))}(w||(w={}));var E,y=w.SDKS.Bitcoin.BitcoinSDK,f=n(454),b=n(126),g=n(89),v=n(127);!function(e){!function(e){!function(e){e.EthereumSDK=class extends m{constructor(){super(...arguments),this.Bip=f,this.ethereumlib=b,this.Web3=v}generateKeyPair(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");const n=this.Bip.fromExtendedKey(e.ext.xpriv).deriveChild(t);return{publicKey:n.getWallet().getPublicKeyString(),address:n.getWallet().getChecksumAddressString(),derivationPath:`m/44'/60'/0'/0/${t}`,privateKey:n.getWallet().getPrivateKeyString(),type:"Ethereum",network:e.network}}generateAddress(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");return{index:t,address:this.Bip.fromExtendedKey(e.ext.xpriv).deriveChild(t).getWallet().getChecksumAddressString(),type:e.network.name}}validateAddress(e,t){return new this.Web3(this.networks[t].provider).utils.isAddress(e.toLowerCase())}getTransactionFee(e){if(!this.networks[e]||this.networks[e].connect)throw new Error("Invalid network");return new Promise((t,n)=>{const r=this.networks[e].feeApi;this.axios.get(r).then(e=>t({high:e.data.high_gas_price,medium:e.data.medium_gas_price,low:e.data.low_gas_price,txHigh:21e3*e.data.high_gas_price/1e18,txMedium:21e3*e.data.medium_gas_price/1e18,txLow:21e3*e.data.low_gas_price/1e18})).catch(e=>n(e.message))})}importWIF(e,t){const n=Buffer.from(e,"hex"),r=this.ethereumlib.fromPrivateKey(n);return{publicKey:`0x${r.getPublicKeyString()}`,address:r.getChecksumAddressString(),privateKey:`0x${r.getPrivateKey().toString("hex")}`,type:this.networks[t].name}}createEthTx(e,t,n,r){const i=Buffer.from(e.privateKey.substr(2),"hex"),s=new this.Web3(e.network.provider);return new Promise(async(o,a)=>{const c=await s.eth.getTransactionCount(e.address),d=n.toString(),h=r.toString(),u=new g({nonce:c,gasPrice:s.utils.toHex(h),gasLimit:s.utils.toHex(21e3),to:t,value:s.utils.toHex(s.utils.toWei(d)),chainId:e.network.chainId});u.sign(i);const p=`0x${u.serialize().toString("hex")}`;return o({transaction:{hash:s.utils.sha3(p),fee:s.utils.fromWei((21e3*r).toString(),"ether"),receiver:t,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:n,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3},hexTx:p})})}broadcastTx(e,t){const n=new this.Web3(this.networks[t].provider);return new Promise(async(t,r)=>{n.eth.sendSignedTransaction(e,(e,n)=>e?r(e):t({hash:n}))})}verifyTxSignature(e){const t=new g(e);return this.VerifyTx=e,!!t.verifySignature()}getTransactionHistory(e,t,n,r){const i=[],s=r=>new Promise(async(s,o)=>{const a=`${this.networks[t].getTranApi+r}&startblock=${n}&sort=desc&apikey=${this.networks.ethToken}`;await this.axios.get(a).then(async t=>t.data.result?(t.data.result.forEach(t=>{let n=t.to,r=!1,s=!1,o=!1;t.from===e[0].toLowerCase()&&(r=!0),t.confirmations>11&&(s=!0),t.to||(n=t.contractAddress,o=!0);const a={sent:r,receiver:n,contractCall:o,confirmed:s,hash:t.hash,blockHeight:t.blockNumber,fee:(t.cumulativeGasUsed/1e9).toString(),value:t.value/1e18,sender:t.from,receivedTime:t.timeStamp,confirmedTime:t.timeStamp,confirmations:t.confirmations};i.push(a)}),s()):s()).catch(e=>o(e))});return new Promise(async(t,n)=>{const r=[];e.forEach(async e=>{r.push(new Promise(async(t,n)=>t(s(e))))});try{await Promise.all(r)}catch(e){return n(e)}return t({addresses:e,totalTransactions:i.length,txs:i})})}getBalance(e,t){let n=0;const r=[],i=e=>new Promise(async(r,i)=>{const s=`${this.networks[t].getBalanceApi+e}&tag=latest&apikey=${this.networks.ethToken}`;await this.axios.get(s).then(e=>{n+=e.data.result,r()}).catch(e=>i(e))});return new Promise(async(t,s)=>{e.forEach(e=>{r.push(new Promise(async(t,n)=>t(i(e))))});try{await Promise.all(r)}catch(e){return s(e)}return t(n<1e12?0:n/1e18)})}accountDiscovery(e,t){const n=[];for(let t=0;t<10;t+=1){const r={address:this.generateKeyPair(e,t).address,index:t,type:e.network.name};n.push(r)}return n}}}(e.Ethereum||(e.Ethereum={}))}(e.SDKS||(e.SDKS={}))}(E||(E={}));var k,T=E.SDKS.Ethereum.EthereumSDK,S=n(653),x=n(657),_=n.n(x),I=n(291),A=n.n(I),K=n(765),P=n.n(K);!function(e){!function(e){!function(e){e.CatalystSDK=class extends m{constructor(){super(...arguments),this.ethereumlib=b,this.Web3=v,this.bip39=a,this.walletHdpath="m/44'/42069'/"}generateHDWallet(e,t){if(!this.bip39.validateMnemonic(e))throw new TypeError("Invalid entropy");return{ext:this.bip39.mnemonicToSeedHex(e),int:null,bip:44,type:42069,network:t}}generateKeyPair(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");const n=Object(S.derivePath)(`${this.walletHdpath+t}'`,e.ext),r=A.a.generateFromSeed(n.key);return{publicKey:r.getPublicKeyString(),address:r.getAddressString(),derivationPath:`${this.walletHdpath+t}'`,privateKey:r.getPrivateKeyString(),type:"Catalyst",network:e.network}}generateAddress(e,t){if(!e.network||e.network.connect)throw new Error("Invalid wallet type");const n=Object(S.derivePath)(`${this.walletHdpath+t}'`,e.ext);return{index:t,address:A.a.generateFromSeed(n.key).getAddressString(),type:e.network.name}}validateAddress(e,t){return new this.Web3(this.networks[t].provider).utils.isAddress(e.toLowerCase())}getTransactionFee(e){if(!this.networks[e]||this.networks[e].connect)throw new Error("Invalid network");return new Promise((t,n)=>{const r=this.networks[e].feeApi;this.axios.get(r).then(e=>t({high:e.data.high_gas_price,medium:e.data.medium_gas_price,low:e.data.low_gas_price,txHigh:21e3*e.data.high_gas_price/1e18,txMedium:21e3*e.data.medium_gas_price/1e18,txLow:21e3*e.data.low_gas_price/1e18})).catch(e=>n(e.message))})}importWIF(e,t){const n=Buffer.from(e,"hex"),r=this.ethereumlib.fromPrivateKey(n);return{publicKey:`0x${r.getPublicKeyString()}`,address:r.getChecksumAddressString(),privateKey:`0x${r.getPrivateKey().toString("hex")}`,type:this.networks[t].name}}createEthTx(e,t,n,r){const i=new this.Web3(e.network.provider);return new Promise(async(s,o)=>{const a=await i.eth.getTransactionCount(e.address),c=n.toString(),d=r.toString(),h=new P.a({nonce:a,gasPrice:i.utils.toHex(d),gasLimit:i.utils.toHex(21e3),to:t,value:i.utils.toHex(i.utils.toWei(c)),data:"0x0"});await h.sign(e.privateKey);const u=`0x${h.serialize().toString("hex")}`;return s({transaction:{hash:i.utils.sha3(u),fee:i.utils.fromWei((21e3*r).toString(),"ether"),receiver:t,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:n,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3},hexTx:u})})}broadcastTx(e,t){const n=new this.Web3(this.networks[t].provider);return new Promise(async(t,r)=>{n.eth.sendSignedTransaction(e,(e,n)=>e?r(e):t({hash:n}))})}verifyTxSignature(e){const t=new g(e);return this.VerifyTx=e,!!t.verifySignature()}getTransactionHistory(e,t,n,r){const i=new _.a({transport:{host:"77.68.110.194",port:5005,type:"http",path:"/api/eth/request"}}),s=async t=>{const s=[],o={};return(await(async(e,t,n)=>{const r=[];for(let i=e;i<=t;i+=1)r.push(n.eth_getBlockByNumber(`0x${i.toString(16)}`,!0));return Promise.all(r)})(n,r,i)).forEach(({transactions:e,timestamp:t})=>{console.log(e),e.length>0&&(s.push(...e),e.forEach(e=>{o[e]=t}))}),(await(async(e,t)=>{const n=[];e.forEach(e=>{n.push(t.eth_getTransactionByHash(e))});const r=Promise.all(n);return console.log(r),r})(s,i)).reduce((n,r)=>(r.from!==e[0]&&r.to!==t||(r.timestamp=o[r.hash],n.push(r)),n),[])},o=[];return new Promise(async(t,n)=>{const r=[];e.forEach(async e=>{r.push(new Promise(async(t,n)=>t((async e=>{(await s(e)).forEach(t=>{let n=t.to,r=!1,i=!1,s=!1;t.from===e.toLowerCase()&&(r=!0),t.confirmations>=1&&(i=!0),t.to||(n=t.contractAddress,s=!0);const a={sent:r,receiver:n,contractCall:s,confirmed:i,hash:t.hash,blockHeight:parseInt(t.blockNumber,16),fee:(parseInt(t.cumulativeGasUsed,16)/1e9).toString(),value:parseInt(t.value,16)/1e18,sender:t.from,receivedTime:parseInt(t.timestamp,16),confirmedTime:parseInt(t.timestamp,16),confirmations:1};o.push(a)})})(e))))});try{await Promise.all(r)}catch(e){return n(e)}return t({addresses:e,totalTransactions:o.length,txs:o})})}getBalance(e,t){const n=new _.a({transport:{host:"77.68.110.194",port:5005,type:"http",path:"/api/eth/request"}});return(e=>new Promise(async(t,r)=>{const i=await n.eth_getBalance(e);t(i?parseInt(i,16)/1e18:0)}))(e[0])}accountDiscovery(e,t){const n=[];for(let t=0;t<10;t+=1){const r={address:this.generateKeyPair(e,t).address,index:t,type:e.network.name};n.push(r)}return n}}}(e.Catalyst||(e.Catalyst={}))}(e.SDKS||(e.SDKS={}))}(k||(k={}));var C=k.SDKS.Catalyst.CatalystSDK;var N,R=[{constant:!0,inputs:[],name:"name",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_spender",type:"address"},{name:"_value",type:"uint256"}],name:"approve",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"totalSupply",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_from",type:"address"},{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transferFrom",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[],name:"decimals",outputs:[{name:"",type:"uint8"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"}],name:"balanceOf",outputs:[{name:"balance",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"symbol",outputs:[{name:"",type:"string"}],payable:!1,stateMutability:"view",type:"function"},{constant:!1,inputs:[{name:"_to",type:"address"},{name:"_value",type:"uint256"}],name:"transfer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!0,inputs:[{name:"_owner",type:"address"},{name:"_spender",type:"address"}],name:"allowance",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"},{payable:!0,stateMutability:"payable",type:"fallback"},{anonymous:!1,inputs:[{indexed:!0,name:"owner",type:"address"},{indexed:!0,name:"spender",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Approval",type:"event"},{anonymous:!1,inputs:[{indexed:!0,name:"from",type:"address"},{indexed:!0,name:"to",type:"address"},{indexed:!1,name:"value",type:"uint256"}],name:"Transfer",type:"event"}];!function(e){!function(e){!function(e){e.ERC20SDK=class{constructor(){this.json=R,this.networks=l,this.axios=u,this.Tx=g,this.Web3=v}generateERC20Wallet(e,t,n,r,i){if(!new this.Web3(e.network.provider).utils.isAddress(r.toLowerCase()))throw new Error("This is not a valid ERC20 contract address");return{decimals:i,address:e.address,network:e.network,name:t,symbol:n,contract:r}}broadcastTx(e,t){const n=new this.Web3(this.networks[t].provider);return new Promise(async(t,r)=>{n.eth.sendSignedTransaction(e,(e,n)=>e?r(e):t({hash:n}))})}estimateGas(e,t,n,r){const i=new(new this.Web3(this.networks[r].provider).eth.Contract)(this.json,e.contract),s=(n*10**e.decimals).toString();return new Promise(async(n,r)=>{i.methods.transfer(t,s).estimateGas({from:e.address},(e,t)=>e?r(e):n(t))})}transfer(e,t,n,r,i){const s=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract),o=(r*10**e.decimals).toString(),a=s.methods.transfer(n,o).encodeABI();return this.createTx(e,t,a,i,n,r)}approveAccount(e,t,n,r,i){const s=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract),o=(r*10**e.decimals).toString(),a=s.methods.approve(n,o).encodeABI();return this.createTx(e,t,a,i)}transferAllowance(e,t,n,r,i){return new Promise(async(s,o)=>{const a=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract);if(await this.checkAllowance(e,n)>=r){const o=(r*10**e.decimals).toString(),c=a.methods.transferFrom(n,e.address,o).encodeABI();return s(this.createTx(e,t,c,i))}return s("You don't have enough allowance")})}checkAllowance(e,t){return this.wallet=e,new Promise(async(n,r)=>{const i=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract);return n(await i.methods.allowance(t,e.address).call())})}getBalance(e){return this.wallet=e,new Promise(async(t,n)=>{const r=new(new this.Web3(e.network.provider).eth.Contract)(this.json,e.contract);return t(await r.methods.balanceOf(e.address).call()/10**e.decimals)})}getTokenData(e,t){return new Promise(async(n,r)=>{const i=new this.Web3(this.networks[t].provider),s=this.json;if("0x"===await i.eth.getCode(e))return r(new Error("This is not a valid ERC20 contract address"));const o=new i.eth.Contract(s,e);await o.methods.balanceOf("0xcc345035D14458B3C012977f96fA1E116760D60a").call().catch(e=>r(new Error("Not a valid ERC20 contract address")));try{const e=await o.methods.decimals().call();return n({name:await o.methods.name().call(),symbol:await o.methods.symbol().call(),decimals:e})}catch(e){return n()}})}getTransactionHistory(e,t){return new Promise(async(n,r)=>{let i=`${this.networks[e.network.name].getErc20TranApi+e.contract}&address=${e.address}&startblock=${t}&sort=desc&apikey=${this.networks.ethToken}`;void 0===t&&(i=`${this.networks[e.network.name].getErc20TranApi+e.contract}&address=${e.address}&sort=desc&apikey=${this.networks.ethToken}`),await this.axios.get(i).then(async t=>{if(!t.data.result)return n();const r=[];return t.data.result.forEach(t=>{const n=t.to;let i=!1,s=!1;t.from===e.address.toLowerCase()&&(i=!0),t.confirmations>11&&(s=!0);const o={sent:i,receiver:n,confirmed:s,hash:t.hash,blockHeight:t.blockNumber,fee:t.cumulativeGasUsed/1e9,value:t.value/10**e.decimals,sender:t.from,confirmedTime:t.timeStamp,confirmations:t.confirmations};r.push(o)}),n(r)}).catch(e=>r(e))})}createTx(e,t,n,r,i,s){const o=new this.Web3(e.network.provider);return new Promise(async(a,c)=>{const d=await o.eth.getTransactionCount(e.address),h=r.toString();let u=1e5;if(i&&s)try{u=await this.estimateGas(e,i,s,t.network.name)}catch(e){c(e)}const p=new this.Tx({nonce:d,gasPrice:o.utils.toHex(h),gasLimit:o.utils.toHex(1e5),to:e.contract,value:0,data:n,chainId:e.network.chainId}),l=Buffer.from(t.privateKey.substr(2),"hex");p.sign(l);const w=`0x${p.serialize().toString("hex")}`;return a({hexTx:w,transaction:{fee:(r*u).toString(),hash:o.utils.sha3(w),receiver:i,confirmed:!1,confirmations:0,blockHeight:-1,sent:!0,value:s,sender:e.address,receivedTime:(new Date).getTime()/1e3,confirmedTime:(new Date).getTime()/1e3}})})}}}(e.ERC20||(e.ERC20={}))}(e.SDKS||(e.SDKS={}))}(N||(N={}));var H,O=N.SDKS.ERC20.ERC20SDK;(H||(H={})).createSDK=function(e){switch(e){case"Bitcoin":return new y;case"Ethereum":return new T;case"Catalyst":return new C;case"ERC20":return new O;default:return new y}};var D,B=H;!function(e){(D||(D={})).CryptoWalletJS=class{constructor(){this.SDKFactory=B}}}();t.default=D.CryptoWalletJS},214:function(e,t,n){"use strict";n.r(t),function(e){n.d(t,"ethToken",function(){return r}),n.d(t,"cryptocompare",function(){return i}),n.d(t,"BITCOIN",function(){return s}),n.d(t,"BITCOIN_TESTNET",function(){return o}),n.d(t,"LITECOIN",function(){return a}),n.d(t,"LITECOIN_TESTNET",function(){return c}),n.d(t,"DASH",function(){return d}),n.d(t,"DASH_TESTNET",function(){return h}),n.d(t,"DOGECOIN",function(){return u}),n.d(t,"DOGECOIN_TESTNET",function(){return p}),n.d(t,"VIACOIN",function(){return l}),n.d(t,"VIACOIN_TESTNET",function(){return w}),n.d(t,"ETHEREUM",function(){return m}),n.d(t,"ETHEREUM_ROPSTEN",function(){return E}),n.d(t,"ETHEREUM_RINKEBY",function(){return y}),n.d(t,"ETHEREUM_KOVAN",function(){return f}),n.d(t,"CATALYST_TESTNET",function(){return b}),n.d(t,"REGTEST",function(){return g});const r=e.env.ETHERSCAN_API_KEY,i=e.env.CRYPTOCOMPARE_API_KEY,s={name:"BITCOIN",bip:0,segwit:!0,discovery:e.env.BITCOIN_DISCOVERY,broadcastUrl:e.env.BITCOIN_BROADCAST,feeApi:e.env.BITCOIN_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"bc",bip32:{private:76066276,public:76067358},pubKeyHash:0,scriptHash:5,wif:128}},o={name:"BITCOIN_TESTNET",type:"testnet",bip:1,segwit:!0,discovery:e.env.BITCOIN_TESTNET_DISCOVERY,broadcastUrl:e.env.BITCOIN_TESTNET_BROADCAST,feeApi:e.env.BITCOIN_TESTNET_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"tb",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239}},a={name:"LITECOIN",bip:2,segwit:!0,discovery:e.env.LITECOIN_DISCOVERY,broadcastUrl:e.env.LITECOIN_BROADCAST,feeApi:e.env.LITECOIN_FEE,connect:{messagePrefix:"Litecoin Signed Message:\n",bip32:{public:27108450,private:27106558},pubKeyHash:48,scriptHash:50,wif:176}},c={name:"LITECOIN_TESTNET",type:"litecoin testnet",bip:1,segwit:!0,discovery:e.env.LITECOIN_TESTNET_DISCOVERY,broadcastUrl:e.env.LITECOIN_TESTNET_BROADCAST,feeApi:e.env.LITECOIN_TESTNET_FEE,connect:{messagePrefix:"Litecoin Signed Message:\n",bip32:{private:70709117,public:70711009},pubKeyHash:111,scriptHash:58,wif:239}},d={name:"DASH",bip:5,segwit:!1,discovery:e.env.DASH_DISCOVERY,feeApi:e.env.DASH_FEE,connect:{messagePrefix:"unused",bip32:{public:76067358,private:76066276},pubKeyHash:76,scriptHash:16,wif:204}},h={name:"DASH_TESTNET",bip:1,segwit:!1,discovery:e.env.DASH_TESTNET_DISCOVERY,feeApi:e.env.DASH_TESTNET_FEE,connect:{messagePrefix:"unused",bip32:{public:70617039,private:70615956},pubKeyHash:140,scriptHash:19,wif:239}},u={name:"DOGECOIN",bip:3,segwit:!1,connect:{messagePrefix:"Dogecoin Signed Message:\n",bip32:{public:49990397,private:49988504},pubKeyHash:30,scriptHash:22,wif:158}},p={name:"DOGECOIN_TESTNET",bip:1,segwit:!1,connect:{messagePrefix:"Dogecoin Signed Message:\n",bip32:{private:70427203,public:70429096},wif:241,public:113,scripthash:196}},l={name:"VIACOIN",segwit:!1,connect:{messagePrefix:"Viacoin Signed Message:\n",bip32:{public:76067358,private:76066276},pubKeyHash:71,scriptHash:33,wif:199}},w={name:"VIACOIN_TESTNET",segwit:!1,connect:{messagePrefix:"Viacoin Signed Message:\n",bip32:{public:70617039,private:70615956},pubKeyHash:127,scriptHash:196,wif:255}},m={name:"ETHEREUM",bip:60,feeApi:e.env.ETHEREUM_FEE,provider:e.env.ETHEREUM_PROVIDER,chainId:1},E={name:"ETHEREUM_ROPSTEN",networkName:"ropsten",bip:60,getTranApi:e.env.ETHEREUM_ROPSTEN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_ROPSTEN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_ROPSTEN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_ROPSTEN_FEE,provider:e.env.ETHEREUM_ROPSTEN_PROVIDER,chainId:3},y={name:"ETHEREUM_RINKEBY",networkName:"rinkeby",bip:60,getTranApi:e.env.ETHEREUM_RINKEBY_GET_TRAN,getBalanceApi:e.env.ETHEREUM_RINKEBY_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_RINKEBY_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_RINKEBY_FEE,provider:e.env.ETHEREUM_RINKEBY_PROVIDER,chainId:4},f={name:"ETHEREUM_KOVAN",networkName:"kovan",bip:60,getTranApi:e.env.ETHEREUM_KOVAN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_KOVAN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_KOVAN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_KOVAN_FEE,provider:e.env.ETHEREUM_KOVAN_PROVIDER,chainId:42},b={name:"CATALYST_TESTNET",networkName:"catalyst",bip:42069,getTranApi:e.env.ETHEREUM_ROPSTEN_GET_TRAN,getBalanceApi:e.env.ETHEREUM_ROPSTEN_GET_BALANCE,getErc20TranApi:e.env.ETHEREUM_ROPSTEN_GET_ERC20_TRAN,feeApi:e.env.ETHEREUM_ROPSTEN_FEE,provider:"http://77.68.110.194:5005/api/eth/request",chainId:2},g={name:"REGTEST",type:"test",bip:0,discovery:e.env.BITCOIN_REGTEST_DISCOVERY,segwit:!1,feeApi:e.env.BITCOIN_REGTEST_FEE,connect:{messagePrefix:"Bitcoin Signed Message:\n",bech32:"bcrt",bip32:{public:70617039,private:70615956},pubKeyHash:111,scriptHash:196,wif:239}}}.call(this,n(8))},299:function(e,t){},301:function(e,t){},345:function(e,t){},346:function(e,t){},655:function(e,t){},697:function(e,t){},747:function(e,t){},751:function(e,t){},764:function(e,t){function n(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}n.keys=function(){return[]},n.resolve=n,e.exports=n,n.id=764}}]);